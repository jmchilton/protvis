<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:tal="http://xml.zope.org/namespaces/tal">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<title>Results</title>
		<link href="/res/styles/list.css" type="text/css" rel="stylesheet" />
		<link id="themeStyles" href="/res/dojo/dijit/themes/claro/claro.css" type="text/css" rel="stylesheet" />
		<link id="themeStyles" href="/res/dojo/dojox/html/resources/ellipsis.css" type="text/css" rel="stylesheet" />
		<script type="text/javascript" src="/res/dojo/dojo/dojo.js" data-dojo-config="parseOnLoad: true"></script>
		<script type="text/javascript" src="/res/scripts/flowchart.js"></script>
		<script type="text/javascript">
			dojo.require("dojo.fx");
			dojo.require("dijit.Dialog");
			dojo.require("dojo._base.connect");
			dojo.require("dijit.DynamicTooltip");
			dojo.require("dojox.html.ellipsis");

			var DetailsDialog;
			var CurrentResults = "";
			var CurrentAnimation = null;
			var PendingAnimations = new Array();
			var Tooltips = new Array();
			var CurrentResultsID = 0;
			var CurrentPeptide = null;
			var CurrentContents = null;
			var CurrentDataset;
			var ResultsVisible;
			var Files = ${files};

			function InArray(arr, e) {
				for (var i in arr) {
					if (arr[i] == e) {
						return true;
					}
				}
				return false;
			}
			
			function BaseUrl(url, remove) {
				if (!remove) {
					remove = [ "q", "start", "sort", "order" ];
				}
				var baseurl = url;
				var srch = url.indexOf("?");
				if (srch >= 0) {
					baseurl = url.substr(srch + 1).split("&");
					var i = baseurl.length - 1;
					while (i >= 0) {
						var p = baseurl[i].split("=");
						for (r in remove) {
							if (p[0] == remove[r]) {
								baseurl.splice(i, 1);
								break;
							}
						}
						--i;
					}
					baseurl.push("");
					baseurl = url.substr(0, srch + 1) + baseurl.join("&");
				} else {
					baseurl += "?";
				}
				return baseurl;
			}

			function GetTypeName(type, full) {
				if (full) {
					switch (type) {
						case 1:
							return "MZML";
						case 2:
							return "MGF";
						case 3:
							return "PepXML";
						case 4:
							return "Mascot";
						case 5:
							return "Omssa";
						case 6:
							return "X! Tandem";
						case 7:
							return "PepXML Comparison";
						case 8:
							return "PeptideProphet";
						case 9:
							return "InterProphet";
						case 10:
							return "ProtXML";
						case 11:
							return "ProteinProphet";
						default:
							return "";
					}
				} else {
					if (type <= 0) {
						return "";
					} else if (type == 1) {
						return "mzml";
					} else if (type == 2) {
						return "mgf";
					} else if (type <= 9) {
						return "pep";
					} else {
						return "prot";
					}
				}
			}
			
			function FindFilesWithDependancy(file, types) {
				var search_deps = [file];
				var deps = new Array();
				var new_deps = new Array();
				for (;;) {
					for (i in Files) {
						var f = Files[i];
						var ds = f["deps"];
						for (var d in ds) {
							if (InArray(search_deps, ds[d])) {
								new_deps.push(f["index"]);
								break;
							}
						}
					}
					if (new_deps.length == 0) {
						break;
					}
					for (var d in new_deps) {
						if (!InArray(deps, new_deps[d])) {
							deps.push(new_deps[d]);
						}
					}
					delete search_deps;
					search_deps = new_deps;
					new_deps = new Array();
				}
				for (var i = deps.length - 1; i >= 0; --i) {
					if (!InArray(types, Files[deps[i]]["type"])) {
						deps.splice(i, 1);
					}
				}
				return deps;
			}
			
			var TableManager = new function() {
				this.Tables = {};
	
				this.Add = function(id, sortcol, sortasc, container, url) {
					this.Tables[id] = { sort_col: sortcol, sort_asc: sortasc, url: url, container: container };
				}
	
				this.Delete = function(id) {
					delete this.Tables[id];
				}
	
				this.Sort = function(id, col) {
					t = this.Tables[id];
					if (t["sort_col"] == col) {
						t["sort_asc"] = !t["sort_asc"];
					} else {
						t["sort_col"] = col;
						t["sort_asc"] = true;
					}
					this.Tables[id] = t;
					document.getElementById(id + '_column_' + col).setAttribute("class", "sortable " + (t["sort_asc"] ? "sort_asc" : "sort_dsc"));
					LoadContents(t["container"], BaseUrl(t["url"], [ "start", "sort", "order" ]) + "sort=" + t["sort_col"] + "&order=" + (t["sort_asc"] ? "asc" : "dsc"));
				}
			}
			
			function SwitchDataset(set) {
				if (set != CurrentDataset) {
					dojo.fx.combine([
						dojo.fx.wipeOut({ node: dojo.byId(CurrentDataset) }),
						dojo.fx.wipeIn({ node: dojo.byId(set) })
					]).play();
					CurrentDataset = set;
				}
			}
			
			function QueueAnimation(anim) {
				dojo.connect(anim, "onEnd", function() {
					if (PendingAnimations.length > 0) {
						CurrentAnimation = PendingAnimations.shift();
						CurrentAnimation.play();
					} else {
						CurrentAnimation = null;
					}
				});
				if (CurrentAnimation == null) {
					CurrentAnimation = anim;
					anim.play();
				} else {
					PendingAnimations.push(anim);
				}
			}

			function LoadContents(container, url) {
				CurrentContents = { url: BaseUrl(url), container: container };
				var oldhits = dojo.byId("data_" + container).firstChild;
				if (oldhits == null) {
					var anim = dojo.fx.wipeIn({
						node: dojo.byId("searching"),
						onEnd: function() {
							if (PendingAnimations.length > 0) {
								CurrentAnimation = PendingAnimations.shift();
								CurrentAnimation.play();
							} else {
								CurrentAnimation = null;
							}
						}
					});
					if (CurrentAnimation == null) {
						CurrentAnimation = anim;
						anim.play();
						delete PendingAnimations;
						PendingAnimations = new Array();
					} else {
						delete PendingAnimations;
						PendingAnimations = new Array();
						PendingAnimations.push(anim);
					}
				} else {
					QueueAnimation(dojo.fx.wipeOut({
						node: oldhits,
						onEnd: function(n) {
							delete Tooltips.shift();
							dojo.byId("data_" + container).removeChild(n);
							if (PendingAnimations.length > 0) {
								CurrentAnimation = PendingAnimations.shift();
								CurrentAnimation.play();
							} else {
								CurrentAnimation = dojo.fx.wipeIn({
									node: dojo.byId("searching"),
									onEnd: function() {
										if (PendingAnimations.length > 0) {
											CurrentAnimation = PendingAnimations.shift();
											CurrentAnimation.play();
										} else {
											CurrentAnimation = null;
										}
									}
								});
								CurrentAnimation.play();
							}
						}
					}));
				}
				dojo.xhrGet({
					url: url,
					load: function(results) {
						var cont = document.createElement("div");
						cont.id = "data_" + container + "_" + ++CurrentResultsID;
						cont.visible = "false";
						cont.style = "display: none";
						cont.innerHTML = results;
						dojo.byId("data_" + container).appendChild(cont);
						executeAjaxResponse(results);
						delete PendingAnimations;
						PendingAnimations = new Array();
						QueueAnimation(dojo.fx.wipeOut({ node: dojo.byId("searching") }));
						QueueAnimation(dojo.fx.wipeIn({ node: cont }));
					},
					error: function() {
						var cont = document.createElement("div");
						cont.id = "data_" + container + "_" + ++CurrentResultsID;
						cont.visible = "false";
						cont.style = "display: none";
						dojo.byId("data_" + container).innerHTML = "Query Error. Server could not be reached";
						dojo.byId("data_" + container).appendChild(cont);
						delete PendingAnimations;
						PendingAnimations = new Array();
						QueueAnimation(dojo.fx.wipeOut({ node: dojo.byId("searching") }));
						QueueAnimation(dojo.fx.wipeIn({ node: cont }));
					}
				});
			}
			
			function FilterCurrent(filter) {
				if (CurrentContents != null) {
					LoadContents(CurrentContents["container"], CurrentContents["url"] + "q=" + filter);
				}
			}
			
			function SearchPeptide(peptide, datafile) {
				CurrentPeptide = peptide;
				var tab = TableManager.Tables["results_" + datafile];
				dojo.xhrGet({
					url: "/peptide?file=${file}&n=" + datafile + "&peptide=" + peptide + "&sort=" + tab["sort_col"] + "&order=" + (tab["sort_asc"] ? "asc" : "dsc"),
					load: function(results) {
						elem = dojo.byId("data_peptides")
						elem.innerHTML = "<span class='link' onclick='ReturnToResults();'>Back to all results</span>" + results;
						SwitchDataset("data_peptides");
					},
					error: function() {
						DetailsDialog.attr("title", "Query Results");
						DetailsDialog.attr("content", "Query Error. Server could not be reached");
						DetailsDialog.attr("style", "width: 300px;");
						DetailsDialog.show();
					}
				});
			}

			function ToggleSpectrums() {
				if (ResultsVisible) {
					dojo.fx.wipeOut({ node: dojo.byId("spectrum_list") }).play();
					ResultsVisible = false;
				} else {
					dojo.fx.wipeIn({ node: dojo.byId("spectrum_list") }).play();
					ResultsVisible = true;
				}
			}

			function SelectInfo(title, type, params) {
				var width = params["width"] ? params["width"] : 500;
				dojo.xhrGet({
					url: "/select?file=${file}&type=" + type + (params["datafile"] ? "&n=" + params["datafile"] : '') + (params["params"] ? "&" + params["params"] : ''),
					load: function(results) {
						DetailsDialog.attr("content", '<div id="" style="overflow:auto; width:' + (width - 16) + 'px;max-height:400px;">' + results + '</div>');
					},
					error: function() {
						DetailsDialog.attr("content", "Query Error. Server could not be reached");
					}
				});
				DetailsDialog.attr("title", title);
				DetailsDialog.attr("content", "<center><span class='dijitContentPaneLoading'>Loading results... Please wait</span></center>");
				DetailsDialog.attr("style", "width: " + width + "px;");
				DetailsDialog.show();
			}

			function DisplayProtein(protein, datafile, off) {
				SelectInfo("Peptides in " + protein, "protein", { datafile: datafile, params: "off=" + off });
			}

			function DisplayIndistinguishableProtein(protein, datafile, off) {
				SelectInfo("Proteins indistinguishable from " + protein, "indistinguishable_protein", { datafile: datafile, params: "off=" + off, width: 400 });
			}

			function DisplayIndistinguishablePeptide(peptide, datafile, off) {
				SelectInfo("Peptides indistinguishable from " + peptide, "indistinguishable_peptide", { datafile: datafile, params: "off=" + off, width: 400 });
			}

			function DisplayQuery(protein, peptide, datafile, off) {
				SelectInfo("Results for in " + protein + "/" + peptide, "query", { datafile: datafile, params: "off=" + off });
			}
			
			function DisplayScore(protein, peptide, datafile, qoff, hoff) {
				SelectInfo("Hit Scores for " + protein + "/" + peptide, "scores", { datafile: datafile, params: "qoff=" + qoff + "&hoff=" + hoff });
			}

			function ReturnToResults() {
				dojo.fx.combine([
					dojo.fx.wipeOut({
						node: dojo.byId("search_peptides"),
						onEnd: function(n) {
							n.innerHTML = "";
						}
					}),
					dojo.fx.wipeIn({ node: dojo.byId("search_hits") })
				]).play();
			}

			dojo.ready(function() {
				// Populate content initially
				CurrentDataset = "data_${index}";
				LoadContents("${index}", "/results?file=${file}&n=${index}&type=${type}&q=&max=50");
				DetailsDialog = new dijit.Dialog({ style: "width: 400px" });
				FlowChartCreate(Files, function(evt, file) {
					var type = GetTypeName(file["type"], false);
					SwitchDataset("data_" + file["index"]);
					LoadContents(file["index"], "/results?file=${file}&n=" + file["index"] + "&type=" + type + "&q=&max=50");
					FlowChartSelect(file["index"]);
				});
				FlowChartSelect(${index});
			});
		</script>
		<script type="text/javascript" src="/res/scripts/main.js"></script>
	</head>
	<body class="claro">
		<div id="navigation_graph" style="width:100%; height:auto; overflow:auto;"></div>
		<br/>
		<div id="searching" style="width: 100%;" class="dijitContentPaneLoading">Searching... Please wait</div>
		<tal:for repeat="n python:range(index)"><div id="data_${n}" style="width:100%;height:0;display:none;"></div></tal:for>
		<div id="data_${index}" style="width:100%"></div>
		<div id="data_peptides" visible="false" style="width: 100%; display: none"></div>
	</body>
</html>
