<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:tal="http://xml.zope.org/namespaces/tal">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<title>Results</title>
		<link href="/res/styles/list.css" type="text/css" rel="stylesheet" />
		<link href="/res/dojo/dijit/themes/dijit.css" rel="stylesheet" />
		<link id="themeStyles" href="/res/dojo/dijit/themes/claro/claro.css" type="text/css" rel="stylesheet" />
		<link id="themeStyles" href="/res/dojo/dojox/html/resources/ellipsis.css" type="text/css" rel="stylesheet" />
		<script type="text/javascript" src="/res/dojo/dojo/dojo.js" data-dojo-config="parseOnLoad: true"></script>
		<script type="text/javascript" src="/res/scripts/flowchart.js"></script>
		<!--<script type="text/javascript" src="/res/scripts/specview.js"></script>-->
		<script type="text/javascript">
			dojo.require("dojo.fx");
			dojo.require("dijit.Dialog");
			dojo.require("dojo._base.connect");
			dojo.require("dijit.DynamicTooltip");
			dojo.require("dojox.html.ellipsis");
			dojo.require("dojox.gfx");
			dojo.require("dojox.form.Uploader");
			dojo.require("dojox.form.uploader.plugins.IFrame");
			
			var Location = function(dataset, table) {
				if (!table) {
					table = "data_" + dataset;
				}
				this.Dataset = dataset;
				this.Table = table;
			}
			
			Element.prototype.byId = function(id) {
				function ChildById(e, id) {
					if (e.children) {
						for (var i in e.children) {
							var c = e.children[i];
							if (c.id == id) {
								return c;
							}
							var found = ChildById(c, id);
							if (found) {
								return found;
							}
						}
					}
					return null;
				}
			
				return ChildById(this, id);
			}

			var DetailsDialog;
			var CurrentResults = "";
			var CurrentAnimation = null;
			var PendingAnimations = new Array();
			var Tooltips = new Array();
			var CurrentResultsID = 0;
			var CurrentPeptide = null;
			var CurrentContents = null;
			var CurrentDataset = new Location(${index});
			var LastDataset = new Location(${index});
			var ResultsVisible;
			var Files = [${files}];
			var Flowchart;
			var Coverages = {};

			function InArray(arr, e) {
				for (var i in arr) {
					if (arr[i] == e) {
						return true;
					}
				}
				return false;
			}
			
			function BaseUrl(url, remove) {
				if (!remove) {
					remove = [ "q", "start", "sort", "order" ];
				}
				var baseurl = url;
				var srch = url.indexOf("?");
				if (srch >= 0) {
					baseurl = url.substr(srch + 1).split("&");
					var i = baseurl.length - 1;
					while (i >= 0) {
						var p = baseurl[i].split("=");
						for (r in remove) {
							if (p[0] == remove[r]) {
								baseurl.splice(i, 1);
								break;
							}
						}
						--i;
					}
					baseurl.push("");
					baseurl = url.substr(0, srch + 1) + baseurl.join("&");
				} else {
					baseurl += "?";
				}
				return baseurl;
			}

			function GetTypeName(type, full) {
				if (full) {
					var missing = (type & 0x80) ? " [missing]" : "";
					switch (type & 0x7F) {
						case 1:
							return "MZML" + missing;
						case 2:
							return "MGF" + missing;
						case 3:
							return "PepXML" + missing;
						case 4:
							return "Mascot" + missing;
						case 5:
							return "Omssa" + missing;
						case 6:
							return "X! Tandem" + missing;
						case 7:
							return "PepXML Comparison" + missing;
						case 8:
							return "PeptideProphet" + missing;
						case 9:
							return "InterProphet" + missing;
						case 10:
							return "ProtXML" + missing;
						case 11:
							return "ProteinProphet" + missing;
						default:
							return "Unknown" + missing;
					}
				} else {
					if (type == 1) {
						return "mzml";
					} else if (type == 2) {
						return "mgf";
					} else if (type <= 9) {
						return "pep";
					} else if (type <= 11) {
						return "prot";
					}
					return "";
				}
			}
			
			function FindFilesWithDependancy(file, types) {
				var search_deps = [file];
				var deps = new Array();
				var new_deps = new Array();
				for (;;) {
					for (i in Files) {
						var f = Files[i];
						var ds = f["deps"];
						for (var d in ds) {
							if (InArray(search_deps, ds[d])) {
								new_deps.push(f["index"]);
								break;
							}
						}
					}
					if (new_deps.length == 0) {
						break;
					}
					for (var d in new_deps) {
						if (!InArray(deps, new_deps[d])) {
							deps.push(new_deps[d]);
						}
					}
					delete search_deps;
					search_deps = new_deps;
					new_deps = new Array();
				}
				for (var i = deps.length - 1; i >= 0; --i) {
					if (!InArray(types, Files[deps[i]]["type"])) {
						deps.splice(i, 1);
					}
				}
				return deps;
			}
			
			function GetDependencies(file) {
				return Files[file]["deps"];
			}
			
			var TableManager = new function() {
				this.Tables = {};
	
				this.Add = function(id, sortcol, sortasc, container, url) {
					this.Tables[id] = { sort_col: sortcol, sort_asc: sortasc, url: url, container: container };
				}
	
				this.Delete = function(id) {
					delete this.Tables[id];
				}
	
				this.Sort = function(id, col) {
					t = this.Tables[id];
					if (t["sort_col"] == col) {
						t["sort_asc"] = !t["sort_asc"];
					} else {
						t["sort_col"] = col;
						t["sort_asc"] = true;
					}
					this.Tables[id] = t;
					document.getElementById(id + '_column_' + col).setAttribute("class", "sortable " + (t["sort_asc"] ? "sort_asc" : "sort_dsc"));
					LoadContents(t["container"], BaseUrl(t["url"], [ "start", "sort", "order" ]) + "sort=" + t["sort_col"] + "&order=" + (t["sort_asc"] ? "asc" : "dsc"));
				}
			}
			
			function SwitchDataset(dataset, table) {
				var set = (dataset instanceof Location) ? dataset : new Location(dataset, table);
				if (set.Table != CurrentDataset.Table) {
					dojo.fx.combine([
						dojo.fx.wipeOut({ node: dojo.byId(CurrentDataset.Table) }),
						dojo.fx.wipeIn({ node: dojo.byId(set.Table) })
					]).play();
					CurrentDataset = set;
				}
				Flowchart.Select(set.Dataset);
			}
			
			function QueueAnimation(anim) {
				dojo.connect(anim, "onEnd", function() {
					if (PendingAnimations.length > 0) {
						CurrentAnimation = PendingAnimations.shift();
						CurrentAnimation.play();
					} else {
						CurrentAnimation = null;
					}
				});
				if (CurrentAnimation == null) {
					CurrentAnimation = anim;
					anim.play();
				} else {
					PendingAnimations.push(anim);
				}
			}

			function LoadContents(container, url) {
				CurrentContents = { url: BaseUrl(url), container: container };
				var oldhits = dojo.byId("data_" + container).firstChild;
				if (oldhits == null) {
					var anim = dojo.fx.wipeIn({
						node: dojo.byId("searching"),
						onEnd: function() {
							if (PendingAnimations.length > 0) {
								CurrentAnimation = PendingAnimations.shift();
								CurrentAnimation.play();
							} else {
								CurrentAnimation = null;
							}
						}
					});
					if (CurrentAnimation == null) {
						CurrentAnimation = anim;
						anim.play();
						delete PendingAnimations;
						PendingAnimations = new Array();
					} else {
						delete PendingAnimations;
						PendingAnimations = new Array();
						PendingAnimations.push(anim);
					}
				} else {
					QueueAnimation(dojo.fx.wipeOut({
						node: oldhits,
						onEnd: function(n) {
							delete Tooltips.shift();
							dojo.byId("data_" + container).removeChild(n);
							if (PendingAnimations.length > 0) {
								CurrentAnimation = PendingAnimations.shift();
								CurrentAnimation.play();
							} else {
								CurrentAnimation = dojo.fx.wipeIn({
									node: dojo.byId("searching"),
									onEnd: function() {
										if (PendingAnimations.length > 0) {
											CurrentAnimation = PendingAnimations.shift();
											CurrentAnimation.play();
										} else {
											CurrentAnimation = null;
										}
									}
								});
								CurrentAnimation.play();
							}
						}
					}));
				}
				dojo.xhrGet({
					url: url,
					load: function(results) {
						var cont = document.createElement("div");
						cont.id = "data_" + container + "_" + ++CurrentResultsID;
						cont.visible = "false";
						cont.style = "display: none";
						cont.innerHTML = results;
						dojo.byId("data_" + container).appendChild(cont);
						executeAjaxResponse(results);
						delete PendingAnimations;
						PendingAnimations = new Array();
						QueueAnimation(dojo.fx.wipeOut({ node: dojo.byId("searching") }));
						QueueAnimation(dojo.fx.wipeIn({ node: cont }));
					},
					error: function() {
						var cont = document.createElement("div");
						cont.id = "data_" + container + "_" + ++CurrentResultsID;
						cont.visible = "false";
						cont.style = "display: none";
						cont.innerHTML = "Query Error. Server could not be reached";
						dojo.byId("data_" + container).appendChild(cont);
						delete PendingAnimations;
						PendingAnimations = new Array();
						QueueAnimation(dojo.fx.wipeOut({ node: dojo.byId("searching") }));
						QueueAnimation(dojo.fx.wipeIn({ node: cont }));
					}
				});
			}
			
			function FilterCurrent(filter) {
				if (CurrentContents != null) {
					LoadContents(CurrentContents["container"], CurrentContents["url"] + "q=" + encodeURIComponent(filter));
				}
			}
			
			function SearchPeptide(peptide, datafile) {
				CurrentPeptide = peptide;
				LastDataset = CurrentDataset;
				dojo.xhrGet({
					url: "/peptide?file=${file}&n=" + datafile + "&peptide=" + peptide,
					load: function(results) {
						elem = dojo.byId("data_peptides")
						elem.innerHTML = "<span class='link' onclick='ReturnToResults();'>Back to all results</span>" + results;
						SwitchDataset(datafile, "data_peptides");
					},
					error: function() {
						DetailsDialog.attr("title", "Query Results");
						DetailsDialog.attr("content", "Query Error. Server could not be reached");
						DetailsDialog.attr("style", "width: 300px;");
						DetailsDialog.show();
					}
				});
			}

			function ToggleSpectrums() {
				if (ResultsVisible) {
					dojo.fx.wipeOut({ node: dojo.byId("spectrum_list") }).play();
					ResultsVisible = false;
				} else {
					dojo.fx.wipeIn({ node: dojo.byId("spectrum_list") }).play();
					ResultsVisible = true;
				}
			}
			
			function ShowSpectrum(dataset, type, offset, spectrum) {
				SwitchDataset(dataset, "data_spectrum");
				LoadContents("spectrum", "/spectrum?file=${file}&n=" + dataset + "&type=" + type + "&off=" + offset + "&spectrum=" + spectrum);
			}
			
			function ShowSpectrumFromPeptide(pepn, spectrum, pep_qoff, pep_hoff) {
				LoadContents("spectrum", "/spectrum?file=${file}&spectrum=" + spectrum + "&pn=" + pepn + "&pqoff=" + pep_qoff + "&phoff=" + pep_hoff);
			}

			function SelectInfo(title, type, params) {
				var width = params["width"] ? params["width"] : 500;
				dojo.xhrGet({
					url: "/select?file=${file}&type=" + type + (params["datafile"] ? "&n=" + params["datafile"] : '') + (params["params"] ? "&" + params["params"] : ''),
					load: function(results) {
						DetailsDialog.attr("content", '<div id="" style="overflow:auto; width:' + (width - 16) + 'px;max-height:400px;">' + results + '</div>');
					},
					error: function() {
						DetailsDialog.attr("content", "Query Error. Server could not be reached");
					}
				});
				DetailsDialog.attr("title", title);
				DetailsDialog.attr("content", "<center><span class='dijitContentPaneLoading'>Loading results... Please wait</span></center>");
				DetailsDialog.attr("style", "width: " + width + "px;");
				DetailsDialog.show();
			}

			function DisplayIndistinguishableProtein(protein, datafile, off) {
				SelectInfo("Proteins indistinguishable from " + protein, "indistinguishable_protein", { datafile: datafile, params: "off=" + off, width: 400 });
			}

			function DisplayIndistinguishablePeptide(peptide, datafile, off) {
				SelectInfo("Peptides indistinguishable from " + peptide, "indistinguishable_peptide", { datafile: datafile, params: "off=" + off, width: 400 });
			}

			function DisplayQuery(protein, peptide, datafile, off) {
				SelectInfo("Results for in " + protein + "/" + peptide, "query", { datafile: datafile, params: "off=" + off });
			}
			
			function DisplayScore(protein, peptide, datafile, qoff, hoff) {
				SelectInfo("Hit Scores for " + protein + "/" + peptide, "scores", { datafile: datafile, params: "qoff=" + qoff + "&hoff=" + hoff });
			}

			function ListProteinPeptides(hash, index, protein, datafile, off) {
				var elem = dojo.byId(hash).byId(index).byId("peptide");
				var all = elem.byId("all");
				if (all.children.length > 0) {
					dojo.fx.combine([
						dojo.fx.wipeOut({ node: elem.byId("best") }),
						dojo.fx.wipeIn({ node: all })
					]).play();
				} else {
					dojo.xhrGet({
						url: "/select?file=${file}&type=protein&n=" + datafile + "&off=" + off,
						load: function(results) {
							all.innerHTML = results;
							dojo.fx.combine([
								dojo.fx.wipeOut({ node: elem.byId("best") }),
								dojo.fx.wipeIn({ node: all })
							]).play();
							executeAjaxResponse(results);
						},
						error: function() {
							all.innerHTML = '<span class="error">Error contacting the server</span>';
							dojo.fx.wipeIn({ node: all }).play();
						}
					});
				}
			}
			
			function AddFile(n) {
				var status = dojo.byId("missing_status_" + n);
				dojo.io.iframe.send({
						form: "missing_form_" + n,
						load: function(response, ioArgs) {
							status.innerHTML = response;
							dojo.fx.wipeIn({ node: status }).play();
							executeAjaxResponse(response);
							return response;
						},
						error: function(response, ioArgs) {
							status.innerHTML = '<span class="error">An error occured while uploading your file<' + '/span>';
							dojo.fx.wipeIn({ node: status }).play();
							return response;
						}
					});
			}

			function HideProteinPeptides(elem) {
				dojo.fx.combine([
					dojo.fx.wipeOut({ node: elem.byId("all") }),
					dojo.fx.wipeIn({ node: elem.byId("best") })
				]).play();
			}

			function ReturnToResults() {
				SwitchDataset(LastDataset);
			}

			dojo.ready(function() {
				// Populate content initially
				LoadContents("${index}", "/results?file=${file}&n=${index}&type=${type}&q=&max=50");
				DetailsDialog = new dijit.Dialog({ style: "width: 400px" });
				Flowchart = new FlowChart(dojo.byId("navigation_graph"), Files, function(evt, file) {
					var type = GetTypeName(file["type"], false);
					SwitchDataset(file["index"]);
					if (dojo.byId("data_" + file["index"]).children.length == 0) {
						LoadContents(file["index"], "/results?file=${file}&n=" + file["index"] + "&type=" + type + "&q=&max=50");
					}
					Flowchart.Select(file["index"]);
				});
				Flowchart.Select(${index});
			});
		</script>
		<script type="text/javascript" src="/res/scripts/main.js"></script>
	</head>
	<body class="claro">
		<div id="selectBtn"></div>
		<tal:if condition="python: nfiles > 1">
			<div id="navigation">
				<div id="navigation_graph" style="width:100%; height:auto; overflow:auto; text-align:center;"></div>
				<br/>
			</div>
		</tal:if>
		<div id="searching" style="width: 100%;" class="dijitContentPaneLoading">Searching... Please wait</div>
		<tal:for repeat="n python:range(index)"><div id="data_${n}" style="width:100%;height:0;display:none;"></div></tal:for>
		<div id="data_${index}" style="width:100%"></div>
		<div id="data_peptides" visible="false" style="width: 100%; display: none"></div>
		<div id="data_spectrum" visible="false" style="width: 100%; display: none"></div>
	</body>
</html>
